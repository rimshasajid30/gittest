"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Content = void 0;
exports.getRichTextValues = getRichTextValues;

var _element = require("@wordpress/element");

var _blocks = require("@wordpress/blocks");

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _utils = require("./utils");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const Content = ({
  value,
  tagName: Tag,
  multiline,
  ...props
}) => {
  // Handle deprecated `children` and `node` sources.
  if (Array.isArray(value)) {
    (0, _deprecated.default)('wp.blockEditor.RichText value prop as children type', {
      since: '6.1',
      version: '6.3',
      alternative: 'value prop as string',
      link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
    });
    value = _blocks.children.toHTML(value);
  }

  const MultilineTag = (0, _utils.getMultilineTag)(multiline);

  if (!value && MultilineTag) {
    value = `<${MultilineTag}></${MultilineTag}>`;
  }

  const content = (0, _element.createElement)(_element.RawHTML, null, value);

  if (Tag) {
    const {
      format,
      ...restProps
    } = props;
    return (0, _element.createElement)(Tag, { ...restProps
    }, content);
  }

  return content;
};

exports.Content = Content;
Content.__unstableIsRichTextContent = {};

function findContent(blocks, richTextValues = []) {
  if (!Array.isArray(blocks)) {
    blocks = [blocks];
  }

  for (const block of blocks) {
    if (block?.type?.__unstableIsRichTextContent === Content.__unstableIsRichTextContent) {
      richTextValues.push(block.props.value);
      continue;
    }

    if (block?.props?.children) {
      findContent(block.props.children, richTextValues);
    }
  }

  return richTextValues;
}

function _getSaveElement({
  name,
  attributes,
  innerBlocks
}) {
  return (0, _blocks.getSaveElement)(name, attributes, innerBlocks.map(_getSaveElement));
}

function getRichTextValues(blocks = []) {
  _blocks.__unstableGetBlockProps.skipFilters = true;
  const values = findContent((Array.isArray(blocks) ? blocks : [blocks]).map(_getSaveElement));
  _blocks.__unstableGetBlockProps.skipFilters = false;
  return values;
}
//# sourceMappingURL=content.js.map